
#include <iostream>
#include <limits>
#include <cfloat>
#include <cmath>
#include <bitset>

int main() {
	std::cout << "double has infinity: " << std::numeric_limits<double>::has_infinity << '\n';
	std::cout << "DBL_MAX is :" << DBL_MAX << "\n";
	std::cout << "1/DBL_MAX is :" << 1/DBL_MAX << "\n";
	std::cout << "a big number is: " << 1e20 << "\n";
	std::cout << "1 over a big number is: " << 1/1e20 << "\n";
	// std::cout << "1 over 0 is: " << 1/0 << "\n";
	std::cout << "square root of -1 is: " << sqrt(-1) << std::endl;
	unsigned short n23_12bit = 0x0A52;
	unsigned short n22_12bit = 0x0A52;
	unsigned short n21_12bit = 0x0A52;
	unsigned short n20_12bit = 0x0A52;
	
	unsigned char cmd0_8bit;
	unsigned char cmd1_8bit;
	unsigned char cmd2_8bit;
	unsigned char cmd3_8bit;
	unsigned char cmd4_8bit;
	unsigned char cmd5_8bit;
	
	cmd0_8bit = (n23_12bit >> 4);
	cmd1_8bit = ((n23_12bit << 4) & 0x00F0) | ((n22_12bit >> 8) & 0x000FF);
	
	std::cout << "n23_12bit = " << std::bitset<16>(n23_12bit) << std::endl;
	std::cout << "shift left by 2 bits:" << std::bitset<16>(n23_12bit<<2) << std::endl;
	std::cout << "n22_12bit = " << std::bitset<16>(n22_12bit) << std::endl;
	std::cout << "cmd0_8bit = " << std::bitset<16>(cmd0_8bit) << std::endl;
	std::cout << "cmd1_8bit = " << std::bitset<16>(cmd1_8bit) << std::endl;
	
	// unsigned kthbit = (1 << k) & n;

	// Create an array of PWM commands for LED 0-23
	// These are 16 bit containers for 12 bit numbers
	// (only cmd[n] & 0x0FFF will be used)
	unsigned short cmd[24] = {0x0000, 0x0001, 0x0002, 0x0003,
							  0x0004, 0x0005, 0x0006, 0x0007,
							  0x0008, 0x0009, 0x000A, 0x000B,
							  0x000C, 0x000D, 0x000E, 0x000F,
							  0x0010, 0x0012, 0x0013, 0x0014,
							  0x0015, 0x0016, 0x0017, 0x0018};

	// Create an array of 8 bit numbers that will be sent to the TLC4957
	// The cmd array will have to be reorganized from 24 12 bit numbers
	// into 36 8 bit numbers with cmd[23] MSB first and cmd[0] LSB last.
	unsigned char sout[36];

	// Determine the number of 12 bit commands.
	int n = sizeof(cmd)/sizeof(cmd[0]);
	int m = sizeof(sout)/sizeof(sout[0]);
	// Determine if they can be evenly distrubuted into 8 bit bytes
	if ((n*12)%8) {
		std::cout << "ERROR! INVALID NUMBER OF 12 BIT COMMANDS!" << std::endl;
		std::cout << n << " times 12 bits is not divisible by 8 bits." << std::endl;
		return 0;
	}
	else {
		std::cout << "Valid number of 12 bit commands." << std::endl;
		std::cout << n << " times 12 bits is divisible by 8 bits." << std::endl;
	}
	// Iterate through each command
	for ( int i = 0; i < n; i++ ) {
		if ((i+1)%2) {	// If i is even ...
			sout[(int)(i*1.5)] = ( cmd[(n-1)-i] >> 4 ) & 0x00FF;				// MS 8 bits fills whole byte
			sout[(int)(i*1.5+1)] = ( cmd[(n-1)-i] << 4 ) & 0x00F0;			// LS 4 bits fills upper half of byte
		}
		else {			// If i is odd ...
			sout[(int)(i*1.5-0.5)] |= ( cmd[(n-1)-i] >> 8 ) & 0x000F;			// MS 4 bits fills lower half of byte
			sout[(int)(i*1.5-0.5+1)] = ( cmd[(n-1)-i] ) & 0x00FF;				// LS 8 bits fills whole byte
		}
	}
	for (int i = 0; i < n; i++) {
		std::cout << "cmd[" << i << "] = " << std::bitset<12>(cmd[i]) << std::endl;
	}
	for (int i = 0; i < m; i++) {
		std::cout << "sout[" << i << "] = " << std::bitset<8>(sout[i]) << std::endl;
	}
	std::cout << "cmd[23] - cmd[0]" << std::endl;
	for (int i = 0; i < n; i++) {
		std::cout << std::bitset<12>(cmd[n-1-i]) << " ";
	}
	std::cout << std::endl;
	std::cout << "sout[0] - sout[35]" << std::endl;
	for (int i = 0; i < m; i++) {
		std::cout << std::bitset<8>(sout[i]) << ", ";
	}
	std::cout << std::endl;
	return 0;
}
