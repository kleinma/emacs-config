#include <ros/ros.h>
#include <geometry_msgs/Twist.h>
#include <nav_msgs/Odometry.h>

// Create a global Twist message to store the commanded velocity
geometry_msgs::Twist vel_cmd_;

// Subscribe to the velocity command and store it in a global variable.
void cmd_velCB(const geometry_msgs::Twist& msg)
{
  vel_cmd_ = msg;
}


int main(int argc, char **argv)
{
  ros::init(argc,argv,"robot_sim"); // name of this node will be "minimal_publisher1"
  ros::NodeHandle n; // two lines to create a publisher object that can talk to ROS

  // Create a publisher object to publish the determined state of the robot. Odometry messages contain both Pose and Twist with covariance. In this simulator, we will not worry about the covariance.
  ros::Publisher robot_statePub = n.advertise<nav_msgs::Odometry>("robot_state",1);

  // Create an Odometry message to store the robot state
  nav_msgs::Odometry robot_state;

  ros::Rate naptime(10); //create a ros object from the ros “Rate” class; set the sleep timer for 10Hz repetition rate
  while(ros::ok()) // do work here in infinite loop (desired for this example), but terminate if detect ROS has faulted
    {
      robot_statePub.publish(robot_state);
      //next line will cause the loop to sleep for the balance of the desired period to achieve the specified loop frequency
      naptime.sleep();
    }
}
