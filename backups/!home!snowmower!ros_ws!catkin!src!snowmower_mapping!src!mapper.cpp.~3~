#include <ros/ros.h>
#include <cmath>
#include "snowmower_mapping/mapper.h"


void Mapper::odomCB(const nav_msgs::Odometry& msg){

  // The point (x1,y1) is set to the last known pose
  double x1 = lastPose_.position.x;
  double y1 = lastPose_.position.y;

  // The point (x2,y2) is set to the new pose
  double x2 = msg.pose.pose.position.x;
  double y2 = msg.pose.pose.position.y;

  // Set the last pose to the new pose for the next iteration
  lastPose_.position.x = x2;
  lastPose_.position.y = y2;

  // Now begin filling in the OccupancyGrid.
  // Start with the circle around the first point.
  // Find the minimum and maximum x values
  double xMin1 = x1-r;
  double xMax1 = x1+r;

  // Find the maximum and minimum columns of the OccupancyGrid corresponding to the max and min x values. The "round" function is used. So a column is selected if the circle extends more than half way into it. Note: The first column is column number 0.
  int xMinMap1 = round(xMin1*ppm_);
  int xMaxMap1 = round(xMax1*ppm_)-1;

  for (int i = xMinMap1; i <= xMaxMap1; i++) {
    // Choose x that is in the middle of a column
    double x = (i - 0.5)/ppm_;
    // FInd the corresponding ymin and ymax values for the current x
    double ymin1 = y1 - sqrt(fabs(r_^2-(x-x1)^2));
    double ymax1 = y1 + sqrt(fabs(r_^2-(x-x1)^2));
    // And what row in the OccupancyGrid they are
    int yMinMap1 = round(ymin1*ppm_);
    int yMaxMap1 = round(ymax1*ppm_)-1;
    for (int j = yMinMap1; j <= yMaxMap1; j++) {
      // todo: Fill in the OccupancyGrid Here
    }
  }

}

/* Constructor */
Mapper::Mapper() {

  occupancyGrid_pub_ = nh_.advertise<nav_msgs::OccupancyGrid>("mowed_map",1);
  odom_sub_ = nh_.subscribe<nav_msgs::Odometry>("odom",10,&Mapper::odomCB,this)

    mowed_map_.resolution = 1.0/ppm_; //

};

/* Destructor */
Mapper::~Mapper() {

};

int main() {
  Mapper mapper;
  ros::spin();

}
